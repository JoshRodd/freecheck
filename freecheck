#!/usr/bin/perl

#---------------
#
#    FreeCheck - a free check printing application released
#                under the GNU General Public Licene.
#
#    Copyright (C) 2000 Eric Sandeen (eric_sandeen@bigfoot.com)
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#---------------

$version = "0.2";
$ConfigFile = "freecheck.cfg";

use Getopt::Long;

# This tells us how to format the strings from the cfg file
# so we can print it as a PostScript definition
# The key read will replace "value" for each of these
# Strings are enclosed in parentheses	(String)	(Foobar)
# Fonts are preceded by a "/"		/FontName	/Arial
# Digits are fine as they are		Digit		123
# Booleans are fine too			Bool		true
# But to be safe, do digits and bools as subroutines:
# Subroutines are in {}			{subr}		{3 mul}

%Formats = qw(
		# Globals
		MICRFontName		/value
		MICRFontSize		{value}
		TransitSymbol		(value)
		OnUsSymbol		(value)
		AmountSymbol		(value)
		DashSymbol		(value)
		MICRVerTweak		{value}
		MICRHorTweak		{value}
		# Account
		CheckNumber		{value}
		PrintCheckBody		{value}
		PrintMICRLine		{value}
		NumPages		{value}
		Name1			(value)
		Name2			(value)
		Address1		(value)
		Address2		(value)
		CityStateZip		(value)
		PhoneNumber		(value)
		BankName		(value)
		BankAddr1		(value)
		BankAddr2		(value)
		BankCityStateZip	(value)
		AuxOnUs			(value)
		Routing			(value)
		OnUs			(value)
		Fraction		(value)
		PrintVOID		{value}
		# Styles
		StandardFontName	/value
		StandardFontSize	{value}
		CheckNumDigits		{value}
		CheckNumFont		/value
		CheckNumSize		{value}
		MemoLineHeight		{value}
		SignatureLineHeight	{value}
		BankInfoHeight		{value}
		AmountLineHeight	{value}
		PayeeLineHeight		{value}
		DateLineHeight		{value}
		# Check Blank Types
		CheckHeight		{value}
		CheckWidth		{value}
		CheckHorOffset		{value}
		CheckVerOffset		{value}
		ChecksPerPage		{value}
		LeftMargin		{value}
		RightMargin		{value}
		TopMargin		{value}
		);
			
# Parse command line options and deal with them:

GetOptions	("account:s",	# Account definition file 
		"checknum:i",	# Check number optional (overrides acct file)
		"pages:i",	# Number of pages to print
		"checkstyle:s",	# Check style (defaults to "normal_style.ps"
		"checktype:s",  # Check blank definition 
		"nomicr",       # Prevents MICR line from printing (body only)
		"nobody",	# Prevents body from printing (MICR line only)
		"showaccounts",	# Show available accounts
		"showstyles",	# Show available check styles
		"showblanks",	# Show available check blanks
		"test",		# Don't increment check n, and print VOID
		"cgi:s",	# Accept big string from CGI script (or similar)
		"help")

or Show_Usage();

if ($opt_help) {
	Show_Usage();
}

# Some defaults...
if (!$opt_cgi) {
	$opt_account = "sample";
	$opt_checktype = "MVG3001";
	$opt_checkstyle = "normal";
}

# Pull the config file into a string...
$config_file = read_file($ConfigFile);

# See what sections are available
Get_Sections();

# If we're missing the [Global] section, or if a requested section
# cannot be found, die.
if (!$global_found) {
	die ("No [Global] section found in config file\n");
} 

if ($accounts !~ /${opt_account}/i) {
	die ("Account $opt_account not found in config file\n");
}

if ($checkblanks !~ /$opt_checktype/i) {
	die ("Check type $opt_checktype not found in config file\n");
}

if ($checkstyles !~ /$opt_checkstyle/i) {
	die ("Style $opt_checkstyle not found in config file\n");
}

# Show list of available sections, if requested
if ($opt_showaccounts || $opt_showstyles || $opt_showblanks) {
	print "\nFreeCheck v$version\n";
	if ($opt_showaccounts) {
		print "Accounts:\n";
		foreach (split(/\s+/,$accounts)) {
			print "\t$_\n";
		}
	}
	if ($opt_showstyles) {
		print "Check Styles:\n";
		foreach (split(/\s+/,$checkstyles)) {
			print "\t$_\n";
		}
	}
	if ($opt_showblanks) {
		print "Check Types:\n";
		foreach (split(/\s+/,$checkblanks)) {
			print "\t$_\n";
		}
	}
	die("\n");
}

# Go through the config and fill up a hash with PostScript defines...
Parse_Config($config_file);

# Overwrite anything we got from the config file with what was on the
# Command Line (if anything...)

if ($opt_checknum) {
	$Definitions{"CheckNumber"} = $opt_checknum;
}

if ($opt_pages) {
	$Definitions{"NumPages"} = $opt_pages;
}

if ($opt_nomicr) {
	$Definitions{"PrintMICRLine"} = "false";
}

if ($opt_nobody) {
	$Definitions{"PrintCheckBody"} = "false";
}

# This probably isn't in the config file (although it might be...)
# so cover both possibilites (true/false)
if ($opt_test) {
	$Definitions{"PrintVOID"} = "true";
} else {
	$Definitions{"PrintVOID"} = "false";
}

# the --cgi option lets us pass in name value pairs in a string.
# This will overwrite anything we got from the config file, or
# from the other command line options (--cgi has the last word)
# Parse as follows:
# name is the first word, everything following it is the value
# each line contains one name/value pair.

while ( $opt_cgi =~ /(^\w+)\s+?(.*$)/mcg ) {
	$Definitions{$1} = $2;
}

##################
# Error Checking #
##################

$error = "";

# Make sure that MICR line is only numbers and symbols

if ( $Definitions{"Routing"} !~ /^R[0-9]+R$/ ) {
	$error = $error . "Error - Routing number must be numeric, with an \"R\" on each end\n";
}

if ( $Definitions{"AuxOnUs"} !~ /^[0-9\-CPS]*$/ ) {
	$error = $error . "Error - Auxiliary On-Us field may only be numeric, with \"-\", and MICR symbols (C,P,S)\n";
}

if ( $Definitions{"OnUs"} !~ /^[0-9\-CPS]+$/ ) {
	$error = $error . "Error - On-Us field may only be numeric, with \"-\", and MICR symbols (C,P,S)\n";
}

if ( $Definitions{"CheckNumber"} !~ /^[0-9]+$/ ) {
	$error = $error . "Error - Check number must be numeric \n";
}

if ( $Definitions{"NumPages"} !~ /^[0-9]+$/ ) {
	$error = $error . "Error - Number of pages must be numeric\n";
}

if ( $Definitions{"Fraction"} !~ /^[0-9]{2}\s*\-\s*[0-9]{1,4}\s*\/\s*[0-9]{3,4}$/ ) {
	$error = $error . "Error - Routing fraction must be numeric, with a \"-\" in the numerator\n";
}

# Get routing symbol and institution number from routing number
$RoutingSymbol = substr($Definitions{"Routing"},1,4);
$Institution = substr($Definitions{"Routing"},5,4);

# Strip any leading zeros...
# Only should be one on routing...
$RoutingSymbol =~ s/^0//;
# One or more on institution
$Institution =~ s/^0+//;

# Fraction format:
#
# 2 digits, a "-", institution number (no leading zeros)
# ------------------------------------------------------
# routing number (no leading zeros)


if ( $Definitions{"Fraction"} !~ /^[0-9]{2}\-${Institution}\/${RoutingSymbol}$/ ) {
	$error = $error . "Error - Routing fraction does not match routing number\n";
}


# Test the MICR line for correctness 
if ( length ($Definitions{"Routing"}) != 11 ) {
	$error = $error . "Error - Routing number must be exactly 9 digits long, with
				an \"R\" on each end\n";
}

# Test the MICR checksum
# Don't forget the real routing number is sandwiched between "Rs"

unless ( ( $Definitions{"Routing"} !~ /^R[0-9]+R$/) || ( length ($Definitions{"Routing"}) != 11 ) ){

	$CheckSum = 0;

	@CheckSumMults = (3, 7, 1, 3, 7, 1, 3, 7);
	for ($Digit = 1; $Digit < 9; $Digit++) {
		$CheckSum = $CheckSum +
			$CheckSumMults[$Digit-1] * substr($Definitions{"Routing"}, $Digit, 1);
	}
	
	$CheckSum = 10 - ($CheckSum % 10);

	# Kludge alert...
	if ($CheckSum == 10) {
		$CheckSum = 0;
	}

	if ( $CheckSum ne substr($Definitions{"Routing"}, 9, 1) ) {
		$error = $error . "Error - Routing Number Checksum Incorrect\n";
	}
}


# die() if we got errors
if ( $error && !$opt_test ) {
	print $error;
	die("Errors Encountered\n");
}

# Print PostScript

# Initial stuff:

print "%!\n";
print "/inch {72 mul} def\n";

# Go through $Definitions and print them out PostScript-Like
Print_Defs();

# Then print the main body
Print_Body();

# Update the config file with the new check number, if it's not just a test
if (!$opt_test && !$opt_cgi) {
	$next_check_number = $Definitions{"CheckNumber"} 
		+ ($Definitions{"NumPages"} * $Definitions{"ChecksPerPage"});

	$config_file = Replace_Val($config_file, "Account", $opt_account, 
				"CheckNumber", $next_check_number);
	write_file ("freecheck.cfg", $config_file);
}

###############
# Subroutines #
###############

# read_file and write_file shamelessly stolen from the File::Slurp module
# Short enough, and I didn't want to require a non-standard module

sub read_file
{
	my ($file) = @_;

	local(*F);
	my $r;
	my (@r);

	open(F, "<$file") || die "open $file: $!";
	@r = <F>;
	close(F);

	return @r if wantarray;
	return join("",@r);
}

sub write_file
{
	my ($f, @data) = @_;

	local(*F);

	open(F, ">$f") || die "open >$f: $!";
	(print F @data) || die "write $f: $!";
	close(F) || die "close $f: $!";
	return 1;
}

# Wow, this is ugly!  Anybody have a better suggestion?
sub Parse_Config {
	local ($config_file) = ($_[0]);
	# Find each section we're looking for...
	while ($config_file =~ /^\[\s*(
					Global |
					Account\s+${opt_account} | 
					Style\s+${opt_checkstyle} |
					CheckBlank\s+${opt_checktype}
					)\s*\]/xmgci) {
		# and get the lines under it one by one
		while ($config_file =~ /(^.+$)/mgc) {
			$line = $+;
			# If this line is a comment, skip it
			if ($line =~ /^#/) {
				next;
			}
			# If the line we just found is a new section..."[...]"
			if ($line =~ /^\[.+\]/) {
				# and it is another section we're looking for
				# Grab the next line, and keep going
				if ($line =~ /\[\s*(
						Global |
						Account\s+${opt_account} |
						Style\s+${opt_checkstyle} |
						CheckBlank\s+${opt_checktype}
						)\s*]/xi) {
					# Grab the next line, and keep going
					next;
				} else {
					# Not a section we need, so break out
					# of the loop
					last;
				}
			}
			
			($key, $val) = split (/\s*=\s*/,$line);
			# Need to strip trailing whitespace...
			$val =~ s/\s*$//;
			$Definitions{$key} = $val;
		} # line-by-line while
	} # section match conditional
}

sub Replace_Val {
	local ($string, $section, $name, $key, $value) = 
	      ($_[0],   $_[1],    $_[2], $_[3], $_[4]);
	# We want to get "[section name] ... key = value" and replace it
	# with the new value.
	
	# s - "." matches ANYTHING including newline
	# m - ^ and $ match after and before any newline
	# in this case, ".+?" means the minimum number of <anything> i.e. end
	# when we find the first instance of $key after [section name]
	$string =~ 
	s/(^\[\s*$section\s+$name\s*\].+?^${key}\s*=\s*).*?$/$+$value/smi;
	$string;
}
# Given a section type, list all the section names of that type
sub Get_Sections {
	local $section;
	while ($config_file =~ /^\[\s*(
					Global |
					Account.+ | 
					Style.+ |
					CheckBlank.+
					)\s*\]/xmgci) {
		$section = $+;
		if ( $section =~/CheckBlank\s+(.+)/i ) {
			$checkblanks = "$+ $checkblanks";
		} elsif ( $section =~/Style\s+(.+)/i ) {
			$checkstyles = "$+ $checkstyles";
		} elsif ( $section =~/Account\s+(.+)/i ) {
			$accounts = "$+ $accounts";
		} elsif ( $section =~/Global/i ) {
			$global_found = "true";
		}
	}
}

sub Show_Usage {
	print "\nFreeCheck v.$version - a Free Check printing Utility\n\n";
	print "Usage: freecheck <options>:\n";
	print "\n";
	print "options:\n";
	print "  --account    <filename>    account to use (default \"$opt_account\")\n";
	print "  --checknum   <integer>     starting check number (overrides cfg)\n";
	print "  --pages      <integer>     number of pages to print (overrides cfg)\n";
	print "  --checkstyle <filename>    check style to use (default \"$opt_checkstyle\")\n";
	print "  --checktype  <filename>    blank check type to use (default \"$opt_checktype\")\n";
	print "  --nomicr                   do not print MICR line\n";
	print "  --nobody                   do not print check body\n";
	print "  --showaccounts             show all configured accounts\n";
	print "  --showstyles               show all configured check styles\n";
	print "  --showblanks               show all configured check blanks\n";
	print "  --help                     print this message\n";
	print "  --test                     print but don't increment check number\n";
	print "                               and print VOID on the check\n";
	print "  --cgi                      accept string from CGI script (see docs)\n";
	print "\nconfig file \"freecheck.cfg\" must be in the same directory,\n";
	print "as the freecheck executable (this will change in the future...)\n";
	die "\n";
}

sub Print_Defs {
	# Go through each def in the hash table, and print according to the
	# formatting hash
	while ( ($key, $val) = each (%Definitions) ) {
		print "/$key\t";
		$_ = $Formats{$key};
		s/value/$val/;
		print;
		print " def\n";
	}
}

sub Print_Body {

# This is the main body of the postscript file, that acts on all of the
# definitions we got from the config file.

print <<END_OF_POSTSCRIPT 

% Other Constants:

% Size of the rectangular box for the amount (digits)
/AmountBoxWidth		{1 inch} def
/AmountBoxHeight	{0.25 inch} def

/LineWidth 		{0.3} def

% Max number of digits in check number, and allocate string
/CheckNumDigits 	4 def
/CheckNumberString 	CheckNumber log floor 1 add cvi string def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Helpful Printing Routines %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Shows a line, then does a "carriage return / line feed"
% But only if the string exists (more than 0 chars)
% (How do we get the current font size (height)?)

/ShowAndCR {
	% A couple copies of the string (now 3 on stack)
	dup dup
	length 0 gt {	% First copy
		show		% Second copy
		stringwidth pop neg 0 rmoveto	% Third copy & move back
		neg 0 exch rmoveto % line down
	} if
} def

% Fix up the MICR line components (replace placeholders with MICR
% characters)
% Argh... surely there's a better way - anyone? use "forall?"

/FixMICR {

	/CheckNumStart -1 def
	/CheckNumEnd -1 def
	/CheckNumInOnUs false def
	/CheckNumInAuxOnUs false def

	% Get starting and ending positions for check number in
	% (Aux)OnUs field
	% (This will break if check number is entered in both fields)
	
	OnUs length 1 sub -1 0 {
		dup  % dups the index
		OnUs exch get (C) 0 get eq {
			/CheckNumInOnUs true def
			% If end number not yet defined, define it
			CheckNumEnd 0 lt {
				/CheckNumEnd exch def
			} {
				/CheckNumStart exch def
			} ifelse
			
		} {
			pop
		} ifelse
	} for
	
	AuxOnUs length 1 sub -1 0 {
		dup  % dups the index
		AuxOnUs exch get (C) 0 get eq {
			/CheckNumInAuxOnUs true def
			% If end number not yet defined, define it
			CheckNumEnd 0 lt {
				/CheckNumEnd exch def
			} {
				/CheckNumStart exch def
			} ifelse
			
		} {
			pop
		} ifelse
	} for
	

	% Replace "R" in routing number with actual transit number symbol
	% That's it - should be no spaces, dashes, or anything but digits
	Routing length 1 sub -1 0 {
		dup  % dups the index
		Routing exch get (R) 0 get eq {
			Routing exch TransitSymbol 0 get put
		} {
			pop
		} ifelse
	} for

	% Replace "S" with space character in AuxOnUs
	AuxOnUs length 1 sub -1 0 {
		dup
		AuxOnUs exch get (S) 0 get eq {
			AuxOnUs exch ( ) 0 get put
		} {
			pop
		} ifelse
	} for
		
	% Replace "-" with dash character in AuxOnUs
	AuxOnUs length 1 sub -1 0 {
		dup
		AuxOnUs exch get (-) 0 get eq {
			AuxOnUs exch DashSymbol 0 get put
		} {
			pop
		} ifelse
	} for	

	% Replace "P" with OnUs character in AuxOnUs
	AuxOnUs length 1 sub -1 0 {
		dup
		OnUs exch get (P) 0 get eq {
			OnUs exch OnUsSymbol 0 get put
		} {
			pop
		} ifelse
	} for	

	% Replace "S" with space character in OnUs
	OnUs length 1 sub -1 0 {
		dup
		OnUs exch get (S) 0 get eq {
			OnUs exch ( ) 0 get put
		} {
			pop
		} ifelse
	} for	

	% Replace "-" with dash character in OnUs
	OnUs length 1 sub -1 0 {
		dup
		OnUs exch get (-) 0 get eq {
			OnUs exch DashSymbol 0 get put
		} {
			pop
		} ifelse
	} for	

	% Replace "P" with OnUs character in OnUs
	OnUs length 1 sub -1 0 {
		dup
		OnUs exch get (P) 0 get eq {
			OnUs exch OnUsSymbol 0 get put
		} {
			pop
		} ifelse
	} for	

} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Feature Printing Routines %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/DrawMemoLine {
	LeftMargin MemoLineHeight CheckHeight mul moveto
	2.5 inch 0 inch rlineto
	-2.5 inch 0 inch rmoveto
	0 2 rmoveto
	(for) show
} def

/DrawSignatureLine { % Expects height of signature line
		 % and right edge of check for
		 % beginning position

	CheckWidth SignatureLineHeight CheckHeight mul moveto
	RightMargin neg 0 rmoveto
	-2.5 inch 0 rmoveto
	2.5 inch 0 inch rlineto

} def

/DrawAmountLine {
	CheckWidth AmountLineHeight CheckHeight mul moveto
	RightMargin neg 0 rmoveto
	(DOLLARS) stringwidth pop neg 0 rmoveto
	(DOLLARS) show
	(DOLLARS) stringwidth pop neg 0 rmoveto
	-2 0 rmoveto
	LeftMargin AmountLineHeight CheckHeight mul lineto
} def

/DrawAccountHolderInfo {
	LeftMargin CheckHeight moveto
	0 TopMargin neg rmoveto
	0 StandardFontSize neg rmoveto

	StandardFontSize Name1 ShowAndCR
	StandardFontSize Name2 ShowAndCR

	StandardFontName findfont
	StandardFontSize 1 sub scalefont
	setfont

	StandardFontSize 1 sub Address1 ShowAndCR
	StandardFontSize 1 sub Address2 ShowAndCR
	StandardFontSize 1 sub CityStateZip ShowAndCR
	StandardFontSize 1 sub PhoneNumber ShowAndCR

	StandardFontName findfont
	StandardFontSize 1 add scalefont
	setfont
} def

/DrawDateLine {
	0.6 CheckWidth mul DateLineHeight CheckHeight mul moveto
	(Date) show
	1 inch 0 rlineto
} def

/DrawBankInfo {
	LeftMargin BankInfoHeight CheckHeight mul moveto

	StandardFontSize BankName ShowAndCR

	StandardFontName findfont
	StandardFontSize 1 sub scalefont
	setfont
	
	StandardFontSize 1 sub BankAddr1 ShowAndCR
	StandardFontSize 1 sub BankAddr2 ShowAndCR
	StandardFontSize 1 sub BankCityStateZip ShowAndCR

	StandardFontName findfont
	StandardFontSize 1 add scalefont
	setfont
} def

/DrawPayeeLine {

	LeftMargin PayeeLineHeight CheckHeight mul moveto
	(ORDER OF) show
	(ORDER OF) stringwidth pop neg  StandardFontSize rmoveto
	(PAY TO THE) show
	0 StandardFontSize neg rmoveto
	4 0 rmoveto
	currentpoint mark
	
	CheckWidth PayeeLineHeight CheckHeight mul moveto
	RightMargin neg 0 rmoveto
	AmountBoxWidth neg 0 rmoveto

	0 AmountBoxHeight rlineto
	AmountBoxWidth 0 rlineto
	0 AmountBoxHeight neg rlineto
	AmountBoxWidth neg 0 rlineto

	-4 0 rmoveto
	
	/Helvetica-Bold findfont
	14 scalefont
	setfont
	
	(\$) stringwidth pop neg 0 rmoveto
	(\$) show
	(\$) stringwidth pop neg 0 rmoveto
	
	-4 0 rmoveto
	cleartomark
	lineto

	StandardFontName findfont
	StandardFontSize scalefont
	setfont

} def

/DrawMICR {
	% 0.25 high, 5.6875 from right edge should be in the middle 
	% of the tolerance band
	CheckWidth 0.25 inch moveto
	-5.6875 inch 0 inch rmoveto
	MICRHorTweak MICRVerTweak rmoveto
	% Now we're at the nominal start of the routing number

	MICRFontName findfont
	MICRFontSize scalefont
	setfont

	% Number of digits in the CheckNumberString
	/CheckNumDigit CheckNumberString length 1 sub def

	CheckNumInAuxOnUs {
		CheckNumEnd -1 CheckNumStart {
			CheckNumDigit 0 ge {
				AuxOnUs exch CheckNumberString CheckNumDigit get put
				/CheckNumDigit CheckNumDigit 1 sub def
			} {
				AuxOnUs exch (0) 0 get put
			} ifelse
		} for
	} if


	AuxOnUs stringwidth pop neg 0 rmoveto
	AuxOnUs show

	Routing show

	CheckNumInOnUs {
		CheckNumEnd -1 CheckNumStart {
			CheckNumDigit 0 ge {
				OnUs exch CheckNumberString CheckNumDigit get put
				/CheckNumDigit CheckNumDigit 1 sub def
			} {
				OnUs exch (0) 0 get put
			} ifelse
		} for
	} if

	OnUs show
		
	StandardFontName findfont
	StandardFontSize scalefont
	setfont
} def

/DrawCheckNumber {
	CheckWidth CheckHeight moveto
	RightMargin neg TopMargin neg rmoveto
	CheckNumFont findfont
	CheckNumSize scalefont
	setfont

	CheckNumberString stringwidth pop neg 0 rmoveto
	0 -14 rmoveto
	CheckNumberString show

	StandardFontName findfont
	StandardFontSize scalefont
	setfont
} def

/DrawFraction {
	0.6 CheckWidth mul CheckHeight moveto
	0 TopMargin neg rmoveto
	0 StandardFontSize neg rmoveto
	Fraction show
} def

/DrawStub {
	CheckHorOffset 2 inch ge {
		save
		newpath
		CheckHorOffset neg 0 translate
		StandardFontName findfont
		StandardFontSize 1 sub scalefont
		setfont
		/StubSpacing {CheckHeight 6 div} def
		CheckHorOffset 2 div StubSpacing 5 mul moveto
		CheckNumberString show
		0.3 inch StubSpacing 4 mul moveto
		(Date ) show
		CheckHorOffset 0.3 inch sub StubSpacing 4 mul lineto
		0.3 inch StubSpacing 3 mul moveto
		(Payee ) show
		CheckHorOffset 0.3 inch sub StubSpacing 3 mul lineto
		0.3 inch StubSpacing 2 mul moveto
		(Amount ) show
		CheckHorOffset 0.3 inch sub StubSpacing 2 mul lineto
		0.3 inch StubSpacing 1 mul moveto
		(Memo ) show
		CheckHorOffset 0.3 inch sub StubSpacing 1 mul lineto
		stroke
		restore
	} if
} def	

/DrawVOID {
	save
	StandardFontName findfont
	50 scalefont
	setfont
	newpath
	CheckWidth 2 div 1 inch moveto
	30 rotate
	(V O I D) stringwidth pop 0 moveto
	(V O I D) true charpath
	stroke
	restore
} def

/DrawCheck {
 
	% Convert CheckNumber integer to a string
	CheckNumber CheckNumberString cvs
	
	PrintCheckBody {
		DrawBankInfo
		DrawAccountHolderInfo
		DrawMemoLine
		DrawSignatureLine
		DrawAmountLine
		DrawPayeeLine
		DrawCheckNumber
		DrawFraction
		DrawDateLine
		DrawStub
	} if

	PrintMICRLine {
		DrawMICR
	} if

	PrintVOID {
		% Draw border around check, and print "VOID" for testing
		0 0 moveto
		CheckWidth 0 lineto
		CheckWidth CheckHeight lineto
		0 CheckHeight lineto

		0 0 lineto

		DrawVOID
	} if

} def


/CurrentPage 1 def

% Replace symbol placeholders with actual glyphs
% Also get starting and ending position for check number
FixMICR

NumPages -1 1 {
	/CheckNumber CheckNumber ChecksPerPage add def
	CheckHorOffset CheckVerOffset translate

	StandardFontName findfont
	StandardFontSize scalefont
	setfont

	LineWidth setlinewidth

	% Loop through printing checks, starting with the bottom one

	ChecksPerPage -1 1 {
		/CheckNumber CheckNumber 1 sub def
		newpath
		DrawCheck
		stroke
		0 CheckHeight translate
	} for

	showpage
	/CheckNumber CheckNumber ChecksPerPage add def
	/CurrentPage CurrentPage 1 add def

} for


END_OF_POSTSCRIPT
;

}
